/*
 *  Copyright 2024-2025 The OpenSSL Project Authors. All Rights Reserved.
 *
 *  Licensed under the Apache License 2.0 (the "License").  You may not use
 *  this file except in compliance with the License.  You can obtain a copy
 *  in the file LICENSE in the source distribution or at
 *  https://www.openssl.org/source/license.html
 */

/*
 * NB: Changes to this file should also be reflected in
 * doc/man7/ossl-guide-quic-server-non-block.pod
 */

#include <string.h>

/* Include the appropriate header file for SOCK_STREAM */
#ifdef _WIN32 /* Windows */
# include <stdarg.h>
# include <winsock2.h>
#else /* Linux/Unix */
# include <err.h>
# include <sys/socket.h>
# include <sys/select.h>
# include <netinet/in.h>
# include <unistd.h>
# include <poll.h>
#endif

#include <openssl/bio.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <openssl/quic.h>

#define POLL_ERROR	(SSL_POLL_EVENT_F | SSL_POLL_EVENT_EC | \
	SSL_POLL_EVENT_EL | SSL_POLL_EVENT_EC | SSL_POLL_EVENT_ECD | \
	SSL_POLL_EVENT_ER | SSL_POLL_EVENT_EW)
#ifdef _WIN32
static const char *progname;

static void vwarnx(const char *fmt, va_list ap)
{
    if (progname != NULL)
        fprintf(stderr, "%s: ", progname);
    vfprintf(stderr, fmt, ap);
    putc('\n', stderr);
}

static void errx(int status, const char *fmt, ...)
{
    va_list ap;

    va_start(ap, fmt);
    vwarnx(fmt, ap);
    va_end(ap);
    exit(status);
}

static void warnx(const char *fmt, ...)
{
    va_list ap;

    va_start(ap, fmt);
    vwarnx(fmt, ap);
    va_end(ap);
}
#endif

/*
 * ALPN strings for TLS handshake. Only 'http/1.0' and 'hq-interop'
 * are accepted.
 */
static const unsigned char alpn_ossltest[] = {
    8,  'h', 't', 't', 'p', '/', '1', '.', '0',
    10, 'h', 'q', '-', 'i', 'n', 't', 'e', 'r', 'o', 'p',
};

/*
 * This callback validates and negotiates the desired ALPN on the server side.
 */
static int select_alpn(SSL *ssl, const unsigned char **out,
                       unsigned char *out_len, const unsigned char *in,
                       unsigned int in_len, void *arg)
{
    if (SSL_select_next_proto((unsigned char **)out, out_len, alpn_ossltest,
                              sizeof(alpn_ossltest), in,
                              in_len) == OPENSSL_NPN_NEGOTIATED)
        return SSL_TLSEXT_ERR_OK;
    return SSL_TLSEXT_ERR_ALERT_FATAL;
}

/* Create SSL_CTX. */
static SSL_CTX *create_ctx(const char *cert_path, const char *key_path)
{
    SSL_CTX *ctx;

    /*
     * An SSL_CTX holds shared configuration information for multiple
     * subsequent per-client connections. We specifically load a QUIC
     * server method here.
     */
    ctx = SSL_CTX_new(OSSL_QUIC_server_method());
    if (ctx == NULL)
        goto err;

    /*
     * Load the server's certificate *chain* file (PEM format), which includes
     * not only the leaf (end-entity) server certificate, but also any
     * intermediate issuer-CA certificates.  The leaf certificate must be the
     * first certificate in the file.
     *
     * In advanced use-cases this can be called multiple times, once per public
     * key algorithm for which the server has a corresponding certificate.
     * However, the corresponding private key (see below) must be loaded first,
     * *before* moving on to the next chain file.
     *
     * The requisite files "chain.pem" and "pkey.pem" can be generated by running
     * "make chain" in this directory.  If the server will be executed from some
     * other directory, move or copy the files there.
     */
    if (SSL_CTX_use_certificate_chain_file(ctx, cert_path) <= 0) {
        fprintf(stderr, "couldn't load certificate file: %s\n", cert_path);
        goto err;
    }

    /*
     * Load the corresponding private key, this also checks that the private
     * key matches the just loaded end-entity certificate.  It does not check
     * whether the certificate chain is valid, the certificates could be
     * expired, or may otherwise fail to form a chain that a client can validate.
     */
    if (SSL_CTX_use_PrivateKey_file(ctx, key_path, SSL_FILETYPE_PEM) <= 0) {
        fprintf(stderr, "couldn't load key file: %s\n", key_path);
        goto err;
    }

    /*
     * Clients rarely employ certificate-based authentication, and so we don't
     * require "mutual" TLS authentication (indeed there's no way to know
     * whether or how the client authenticated the server, so the term "mutual"
     * is potentially misleading).
     *
     * Since we're not soliciting or processing client certificates, we don't
     * need to configure a trusted-certificate store, so no call to
     * SSL_CTX_set_default_verify_paths() is needed.  The server's own
     * certificate chain is assumed valid.
     */
    SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);

    /* Setup ALPN negotiation callback to decide which ALPN is accepted. */
    SSL_CTX_set_alpn_select_cb(ctx, select_alpn, NULL);

    return ctx;

err:
    SSL_CTX_free(ctx);
    return NULL;
}

/* Create UDP socket on the given port. */
static int create_socket(uint16_t port)
{
    int fd;
    struct sockaddr_in sa = {0};

    /* Retrieve the file descriptor for a new UDP socket */
    if ((fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
        fprintf(stderr, "cannot create socket");
        return -1;
    }

    sa.sin_family = AF_INET;
    sa.sin_port = htons(port);

    /* Bind to the new UDP socket on localhost */
    if (bind(fd, (const struct sockaddr *)&sa, sizeof(sa)) < 0) {
        fprintf(stderr, "cannot bind to %u\n", port);
        BIO_closesocket(fd);
        return -1;
    }

    /* Set port to nonblocking mode */
    if (BIO_socket_nbio(fd, 1) <= 0) {
        fprintf(stderr, "Unable to set port to nonblocking mode");
        BIO_closesocket(fd);
        return -1;
    }

    return fd;
}

/**
 * @brief Handles I/O failures on an SSL connection based on the result code.
 *
 * This function processes the result of an SSL I/O operation and handles
 * different types of errors that may occur during the operation. It takes
 * appropriate actions such as retrying the operation, reporting errors, or
 * returning specific status codes based on the error type.
 *
 * @param ssl A pointer to the SSL object representing the connection.
 * @param res The result code from the SSL I/O operation.
 * @return An integer indicating the outcome:
 *         - 1: Temporary failure, the operation should be retried.
 *         - 0: EOF, indicating the connection has been closed.
 *         - -1: A fatal error occurred or the connection has been reset.
 *
 * @note If the failure is due to an SSL verification error, additional
 * information will be logged to stderr.
 */
static int handle_io_failure(SSL *ssl, int res)
{
    switch (SSL_get_error(ssl, res)) {
    case SSL_ERROR_WANT_READ:
    case SSL_ERROR_WANT_WRITE:
        return 1;

    case SSL_ERROR_ZERO_RETURN:
    case SSL_ERROR_NONE:
        /* EOF */
        return 0;

    case SSL_ERROR_SYSCALL:
        return -1;

    case SSL_ERROR_SSL:
        /*
         * Some stream fatal error occurred. This could be because of a
         * stream reset - or some failure occurred on the underlying
         * connection.
         */
        switch (SSL_get_stream_read_state(ssl)) {
        case SSL_STREAM_STATE_RESET_REMOTE:
            printf("Stream reset occurred\n");
            /*
             * The stream has been reset but the connection is still
             * healthy.
             */
            break;

        case SSL_STREAM_STATE_CONN_CLOSED:
            printf("Connection closed\n");
            /* Connection is already closed. */
            break;

        default:
            printf("Unknown stream failure\n");
            break;
        }
        /*
         * If the failure is due to a verification error we can get more
         * information about it from SSL_get_verify_result().
         */
        if (SSL_get_verify_result(ssl) != X509_V_OK)
            printf("Verify error: %s\n",
                   X509_verify_cert_error_string(SSL_get_verify_result(ssl)));
        return -1;

    default:
        return -1;
    }
}

/*
 * Main loop for server to accept QUIC connections.
 * Echo every request back to the client.
 */
static int run_quic_server(SSL_CTX *ctx, int fd)
{
    int ok = -1;
    int ret;
    SSL *listener, *conn = NULL, *stream = NULL;
    unsigned char buf[8192];
    size_t nread, total_read, total_written;
    /* listener and connection, just two items to keep things simple */
    SSL_POLL_ITEM poll_set[3];
    size_t poll_items;
    int do_accept = 1;

    memset(poll_set, 0, sizeof (poll_set));
    /* Create a new QUIC listener */
    if ((listener = SSL_new_listener(ctx, 0)) == NULL)
        goto err;

    if (!SSL_set_fd(listener, fd))
        goto err;

    /*
     * Set the listener mode to non-blocking, which is inherited by
     * child objects.
     */
    if (!SSL_set_blocking_mode(listener, 0))
        goto err;

    /*
     * Begin listening. Note that is not usually needed as SSL_accept_connection
     * will implicitly start listening. It is only needed if a server wishes to
     * ensure it has started to accept incoming connections but does not wish to
     * actually call SSL_accept_connection yet.
     */
    if (!SSL_listen(listener))
        goto err;

    poll_set[0].desc = SSL_as_poll_descriptor(listener);
    poll_set[0].events = SSL_POLL_EVENT_IC;

    /*
     * Begin an infinite loop of listening for connections. We will only
     * exit this loop if we encounter an error.
     */
    for (;;) {
        total_read = 0;
        total_written = 0;

        /* Pristine error stack for each new connection */
        ERR_clear_error();

        /* Block while waiting for a client connection */
        printf("Waiting for connection\n");
        /*
         * to keep things simple we process one connection at a time.
         * we poll on one poll descriptor (listener) when we are need to accept
	 * connection. We poll on two descriptors (listener, connection) when
	 * we need to handle connection data.
         */
        if (listener != NULL)
            poll_items = 1;
        if (conn != NULL)
            poll_items = 2;
        if (stream != NULL)
            poll_items = 3;

        ok = SSL_poll(poll_set, poll_items, sizeof (SSL_POLL_ITEM), NULL,
                      0, &poll_items);
	printf("poll_items: %zu\n", poll_items);
            fprintf(stderr, "listener (0x%llx) event %s%s%s%s%s%s%s%s%s%s%s%s%s\n", poll_set[0].revents,
                poll_set[0].revents & SSL_POLL_EVENT_F ? "SSL_POLL_EVENT_F" : "",
                poll_set[0].revents & SSL_POLL_EVENT_EL ? "SSL_POLL_EVENT_EL" : "",
                poll_set[0].revents & SSL_POLL_EVENT_EC ? "SSL_POLL_EVENT_EC" : "",
                poll_set[0].revents & SSL_POLL_EVENT_ECD ? "SSL_POLL_EVENT_ECD" : "",
                poll_set[0].revents & SSL_POLL_EVENT_ER? "SSL_POLL_EVENT_ER" : "",
                poll_set[0].revents & SSL_POLL_EVENT_EW? "SSL_POLL_EVENT_EW" : "",
                poll_set[0].revents & SSL_POLL_EVENT_R? "SSL_POLL_EVENT_R" : "",
                poll_set[0].revents & SSL_POLL_EVENT_W? "SSL_POLL_EVENT_W" : "",
                poll_set[0].revents & SSL_POLL_EVENT_IC? "SSL_POLL_EVENT_IC" : "",
                poll_set[0].revents & SSL_POLL_EVENT_ISB? "SSL_POLL_EVENT_ISB" : "",
                poll_set[0].revents & SSL_POLL_EVENT_ISU? "SSL_POLL_EVENT_ISU" : "",
                poll_set[0].revents & SSL_POLL_EVENT_OSB? "SSL_POLL_EVENT_OSB" : "",
                poll_set[0].revents & SSL_POLL_EVENT_OSU? "SSL_POLL_EVENT_OSU" : "");
if (conn != NULL)
            fprintf(stderr, "conn (0x%llx) event %s%s%s%s%s%s%s%s%s%s%s%s%s\n", poll_set[1].revents,
                poll_set[1].revents & SSL_POLL_EVENT_F ? "SSL_POLL_EVENT_F" : "",
                poll_set[1].revents & SSL_POLL_EVENT_EL ? "SSL_POLL_EVENT_EL" : "",
                poll_set[1].revents & SSL_POLL_EVENT_EC ? "SSL_POLL_EVENT_EC" : "",
                poll_set[1].revents & SSL_POLL_EVENT_ECD ? "SSL_POLL_EVENT_ECD" : "",
                poll_set[1].revents & SSL_POLL_EVENT_ER? "SSL_POLL_EVENT_ER" : "",
                poll_set[1].revents & SSL_POLL_EVENT_EW? "SSL_POLL_EVENT_EW" : "",
                poll_set[1].revents & SSL_POLL_EVENT_R? "SSL_POLL_EVENT_R" : "",
                poll_set[1].revents & SSL_POLL_EVENT_W? "SSL_POLL_EVENT_W" : "",
                poll_set[1].revents & SSL_POLL_EVENT_IC? "SSL_POLL_EVENT_IC" : "",
                poll_set[1].revents & SSL_POLL_EVENT_ISB? "SSL_POLL_EVENT_ISB" : "",
                poll_set[1].revents & SSL_POLL_EVENT_ISU? "SSL_POLL_EVENT_ISU" : "",
                poll_set[1].revents & SSL_POLL_EVENT_OSB? "SSL_POLL_EVENT_OSB" : "",
                poll_set[1].revents & SSL_POLL_EVENT_OSU? "SSL_POLL_EVENT_OSU" : "");
if (stream != NULL)
            fprintf(stderr, "stream (0x%llx) event %s%s%s%s%s%s%s%s%s%s%s%s%s\n", poll_set[2].revents,
                poll_set[2].revents & SSL_POLL_EVENT_F ? "SSL_POLL_EVENT_F" : "",
                poll_set[2].revents & SSL_POLL_EVENT_EL ? "SSL_POLL_EVENT_EL" : "",
                poll_set[2].revents & SSL_POLL_EVENT_EC ? "SSL_POLL_EVENT_EC" : "",
                poll_set[2].revents & SSL_POLL_EVENT_ECD ? "SSL_POLL_EVENT_ECD" : "",
                poll_set[2].revents & SSL_POLL_EVENT_ER? "SSL_POLL_EVENT_ER" : "",
                poll_set[2].revents & SSL_POLL_EVENT_EW? "SSL_POLL_EVENT_EW" : "",
                poll_set[2].revents & SSL_POLL_EVENT_R? "SSL_POLL_EVENT_R" : "",
                poll_set[2].revents & SSL_POLL_EVENT_W? "SSL_POLL_EVENT_W" : "",
                poll_set[2].revents & SSL_POLL_EVENT_IC? "SSL_POLL_EVENT_IC" : "",
                poll_set[2].revents & SSL_POLL_EVENT_ISB? "SSL_POLL_EVENT_ISB" : "",
                poll_set[2].revents & SSL_POLL_EVENT_ISU? "SSL_POLL_EVENT_ISU" : "",
                poll_set[2].revents & SSL_POLL_EVENT_OSB? "SSL_POLL_EVENT_OSB" : "",
                poll_set[2].revents & SSL_POLL_EVENT_OSU? "SSL_POLL_EVENT_OSU" : "");
        if (ok == 0) {
            ok = -1;
            goto err;
        }

        if (do_accept == 1 && poll_set[0].revents & SSL_POLL_EVENT_IC) {
            conn = SSL_accept_connection(listener, 0);
            if (conn == NULL)
                goto err;
            do_accept = 0;
            printf("Accepted new connection\n");
            poll_set[1].desc = SSL_as_poll_descriptor(conn);
            poll_set[1].events = SSL_POLL_EVENT_IS;
            continue;	/* back to the start of for() loop so poll again */
        } else if (poll_items == 3 && poll_set[2].revents & SSL_POLL_EVENT_R) {
            /* Read from client until the client sends a end of stream packet */
            fprintf(stderr, "trying to read\n");
            ret = SSL_read_ex(conn, buf + total_read, sizeof(buf) - total_read,
                              &nread);
            total_read += nread;
            if (total_read >= 8192) {
                fprintf(stderr, "Could not fit all data into buffer\n");
                goto err;
            }

            fprintf(stderr, "got data %s\n", buf);
            switch (handle_io_failure(conn, ret)) {
            case 1:
                continue; /* back to poll */
            case 0:
                /* Reached end of stream */
                if (!SSL_has_pending(conn)) {
                    poll_set[1].events = SSL_POLL_EVENT_W;
                }
                continue /* back to poll */;
            default:
                fprintf(stderr, "Failed reading remaining data\n");
                goto err;
            }
        } else if (poll_items == 3 && poll_set[2].revents & SSL_POLL_EVENT_W) {
            fprintf(stderr, "trying to write\n");
            ret = SSL_write_ex2(conn, buf, total_read,
                                SSL_WRITE_FLAG_CONCLUDE, &total_written);
            if (ret == 0) {
                if (handle_io_failure(conn, 0) == 1)
                    continue;
                fprintf(stderr, "Failed to write data\n");
                goto err;
            }

            if (total_read != total_written)
                fprintf(stderr, "Failed to echo data [read: %lu, written: %lu]\n",
                        total_read, total_written);

            switch (SSL_shutdown(conn)) {
            case 0:
                continue; /* back to poll */
            case 1:
                SSL_free(conn);
                conn = NULL;
                do_accept = 1; /* connection is we can accept new */
                continue; /* back to poll */
            }
        } else if (poll_items > 1 && poll_set[1].revents & SSL_POLL_EVENT_ISB) {
            printf("accepting stream\n");
            stream = SSL_accept_stream(conn, SSL_ACCEPT_STREAM_NO_BLOCK);
            if (stream == NULL)
                continue;
            poll_set[2].desc = SSL_as_poll_descriptor(stream);
            poll_set[2].events = SSL_POLL_EVENT_R;
        } else if (poll_set[0].revents) {
            fprintf(stderr, "listener error %s%s%s%s%s%s%s%s%s%s\n",
                poll_set[0].revents & SSL_POLL_EVENT_RW ? "SSL_POLL_EVENT_RW" : "",
                poll_set[0].revents & SSL_POLL_EVENT_RE ? "SSL_POLL_EVENT_RE" : "",
                poll_set[0].revents & SSL_POLL_EVENT_WE ? "SSL_POLL_EVENT_WE" : "",
                poll_set[0].revents & SSL_POLL_EVENT_RWE ? "SSL_POLL_EVENT_RWE" : "",
                poll_set[0].revents & SSL_POLL_EVENT_E ? "SSL_POLL_EVENT_E" : "",
                poll_set[0].revents & SSL_POLL_EVENT_IS ? "SSL_POLL_EVENT_IS" : "",
                poll_set[0].revents & SSL_POLL_EVENT_ISE ? "SSL_POLL_EVENT_ISE" : "",
                poll_set[0].revents & SSL_POLL_EVENT_I ? "SSL_POLL_EVENT_I" : "",
                poll_set[0].revents & SSL_POLL_EVENT_OS ? "SSL_POLL_EVENT_OS" : "",
                poll_set[0].revents & SSL_POLL_EVENT_OSE ? "SSL_POLL_EVENT_OSE" : "");
            SSL_free(conn);
            goto err;
        } else if (poll_items > 1 && poll_set[1].revents) {
            fprintf(stderr, "listener error %s%s%s%s%s%s%s%s%s%s\n",
                poll_set[1].revents & SSL_POLL_EVENT_RW ? "SSL_POLL_EVENT_RW" : "",
                poll_set[1].revents & SSL_POLL_EVENT_RE ? "SSL_POLL_EVENT_RE" : "",
                poll_set[1].revents & SSL_POLL_EVENT_WE ? "SSL_POLL_EVENT_WE" : "",
                poll_set[1].revents & SSL_POLL_EVENT_RWE ? "SSL_POLL_EVENT_RWE" : "",
                poll_set[1].revents & SSL_POLL_EVENT_E ? "SSL_POLL_EVENT_E" : "",
                poll_set[1].revents & SSL_POLL_EVENT_IS ? "SSL_POLL_EVENT_IS" : "",
                poll_set[1].revents & SSL_POLL_EVENT_ISE ? "SSL_POLL_EVENT_ISE" : "",
                poll_set[1].revents & SSL_POLL_EVENT_I ? "SSL_POLL_EVENT_I" : "",
                poll_set[1].revents & SSL_POLL_EVENT_OS ? "SSL_POLL_EVENT_OS" : "",
                poll_set[1].revents & SSL_POLL_EVENT_OSE ? "SSL_POLL_EVENT_OSE" : "");
            SSL_shutdown(conn);
            SSL_free(conn);
            conn = NULL;
            do_accept = 1;
        } else if (poll_items == 3 && poll_set[2].revents) {
            fprintf(stderr, "listener error %s%s%s%s%s%s%s%s%s%s\n",
                poll_set[2].revents & SSL_POLL_EVENT_RW ? "SSL_POLL_EVENT_RW" : "",
                poll_set[2].revents & SSL_POLL_EVENT_RE ? "SSL_POLL_EVENT_RE" : "",
                poll_set[2].revents & SSL_POLL_EVENT_WE ? "SSL_POLL_EVENT_WE" : "",
                poll_set[2].revents & SSL_POLL_EVENT_RWE ? "SSL_POLL_EVENT_RWE" : "",
                poll_set[2].revents & SSL_POLL_EVENT_E ? "SSL_POLL_EVENT_E" : "",
                poll_set[2].revents & SSL_POLL_EVENT_IS ? "SSL_POLL_EVENT_IS" : "",
                poll_set[2].revents & SSL_POLL_EVENT_ISE ? "SSL_POLL_EVENT_ISE" : "",
                poll_set[2].revents & SSL_POLL_EVENT_I ? "SSL_POLL_EVENT_I" : "",
                poll_set[2].revents & SSL_POLL_EVENT_OS ? "SSL_POLL_EVENT_OS" : "",
                poll_set[2].revents & SSL_POLL_EVENT_OSE ? "SSL_POLL_EVENT_OSE" : "");
            SSL_shutdown(conn);
            SSL_free(conn);
            conn = NULL;
            do_accept = 1;
        }
    }

    ok = EXIT_SUCCESS;
err:
    SSL_free(listener);
    return ok;
}

/* Minimal QUIC HTTP/1.0 server. */
int main(int argc, char *argv[])
{
    int res = EXIT_FAILURE;
    SSL_CTX *ctx = NULL;
    int fd;
    unsigned long port;

#ifdef _WIN32
    progname = argv[0];
#endif

    if (argc != 4)
        errx(res, "usage: %s <port> <server.crt> <server.key>", argv[0]);

    /* Create SSL_CTX that supports QUIC. */
    if ((ctx = create_ctx(argv[2], argv[3])) == NULL) {
        ERR_print_errors_fp(stderr);
        errx(res, "Failed to create context");
    }

    /* Parse port number from command line arguments. */
    port = strtoul(argv[1], NULL, 0);
    if (port == 0 || port > UINT16_MAX) {
        SSL_CTX_free(ctx);
        errx(res, "Failed to parse port number");
    }

    /* Create and bind a UDP socket. */
    if ((fd = create_socket((uint16_t)port)) < 0) {
        SSL_CTX_free(ctx);
        ERR_print_errors_fp(stderr);
        errx(res, "Failed to create socket");
    }

    /* QUIC server connection acceptance loop. */
    if (run_quic_server(ctx, fd) < 0) {
        SSL_CTX_free(ctx);
        BIO_closesocket(fd);
        ERR_print_errors_fp(stderr);
        errx(res, "Error in QUIC server loop");
    }

    /* Free resources. */
    SSL_CTX_free(ctx);
    BIO_closesocket(fd);
    res = EXIT_SUCCESS;
    return res;
}
